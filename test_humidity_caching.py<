#!/usr/bin/env python3
"""Test script to verify humidity sensor caching functionality."""

import asyncio
import time
import unittest
from unittest.mock import Mock, patch, AsyncMock

from custom_components.ramses_extras.features.humidity_control.platforms.sensor import HumidityAbsoluteSensor


class TestHumidityCaching(unittest.TestCase):
    """Test humidity sensor caching behavior."""

    def setUp(self):
        """Set up test fixtures."""
        self.hass = Mock()
        self.device_id = "32:153289"
        self.sensor_type = "indoor_absolute_humidity"
        self.config = {
            "unit": "g/mÂ³",
            "device_class": "humidity",
            "name_template": "Indoor Absolute Humidity {device_id}",
        }

        self.sensor = HumidityAbsoluteSensor(
            self.hass, self.device_id, self.sensor_type, self.config
        )

    def test_cache_behavior(self):
        """Test that caching works correctly."""
        # Create separate state objects for each call
        temp_state1 = Mock()
        temp_state1.state = "20.5"
        humidity_state1 = Mock()
        humidity_state1.state = "60.0"

        temp_state2 = Mock()
        temp_state2.state = "20.5"  # Same values
        humidity_state2 = Mock()
        humidity_state2.state = "60.0"

        def mock_get(entity_id):
            if "indoor_temp" in entity_id:
                # Return different objects but same values
                if not hasattr(mock_get, 'call_count'):
                    mock_get.call_count = 0
                mock_get.call_count += 1
                return temp_state1 if mock_get.call_count % 2 == 1 else temp_state2
            elif "indoor_humidity" in entity_id:
                if not hasattr(mock_get, 'humidity_call_count'):
                    mock_get.humidity_call_count = 0
                mock_get.humidity_call_count += 1
                return humidity_state1 if mock_get.humidity_call_count % 2 == 1 else humidity_state2
            return None

        with patch.object(self.hass.states, "get", side_effect=mock_get):
            # First call should calculate
            result1 = self.sensor.native_value
            self.assertIsNotNone(result1)
            self.assertEqual(self.sensor._last_temp, 20.5)
            self.assertEqual(self.sensor._last_humidity, 60.0)
            self.assertEqual(self.sensor._last_absolute_humidity, result1)

            # Second call immediately after should use cache (same values)
            result2 = self.sensor.native_value
            self.assertEqual(result1, result2)

            # Verify cache time was set
            self.assertGreater(self.sensor._last_calculation_time, 0)

    def test_cache_expiration(self):
        """Test that cache expires after the configured duration."""
        # Create state objects
        temp_state = Mock()
        temp_state.state = "20.5"
        humidity_state = Mock()
        humidity_state.state = "60.0"

        call_count = 0
        def mock_get(entity_id):
            nonlocal call_count
            call_count += 1
            if "indoor_temp" in entity_id:
                return temp_state
            elif "indoor_humidity" in entity_id:
                return humidity_state
            return None

        with patch.object(self.hass.states, "get", side_effect=mock_get):
            # First call should calculate
            result1 = self.sensor.native_value

            # Manually set old timestamp to force cache expiration
            self.sensor._last_calculation_time = time.time() - 20.0  # 20 seconds ago

            # This should trigger recalculation due to cache expiration
            result2 = self.sensor.native_value
            # Results should be the same but calculation should happen again
            self.assertEqual(result1, result2)
            # Should have been called more times due to cache expiration
            self.assertGreater(call_count, 2)

    def test_value_change_triggers_recalculation(self):
        """Test that changing values trigger recalculation."""
        call_count = 0

        def mock_get(entity_id):
            nonlocal call_count
            call_count += 1

            if call_count == 1 or call_count == 2:  # First calculation
                if "indoor_temp" in entity_id:
                    temp_state = Mock()
                    temp_state.state = "20.0"
                    return temp_state
                elif "indoor_humidity" in entity_id:
                    humidity_state = Mock()
                    humidity_state.state = "50.0"
                    return humidity_state
            elif call_count == 3 or call_count == 4:  # Second calculation with different values
                if "indoor_temp" in entity_id:
                    temp_state = Mock()
                    temp_state.state = "21.0"  # Changed temperature
                    return temp_state
                elif "indoor_humidity" in entity_id:
                    humidity_state = Mock()
                    humidity_state.state = "55.0"  # Changed humidity
                    return humidity_state

            return None

        with patch.object(self.hass.states, "get", side_effect=mock_get):
            # First calculation
            result1 = self.sensor.native_value
            self.assertEqual(self.sensor._last_temp, 20.0)
            self.assertEqual(self.sensor._last_humidity, 50.0)

            # Second calculation with different values
            result2 = self.sensor.native_value
            self.assertEqual(self.sensor._last_temp, 21.0)
            self.assertEqual(self.sensor._last_humidity, 55.0)
            self.assertNotEqual(result1, result2)

    async def test_cache_clearing_on_update(self):
        """Test that cache is cleared when update handler is called."""
        # Set some cache values
        self.sensor._last_temp = 20.0
        self.sensor._last_humidity = 50.0
        self.sensor._last_absolute_humidity = 8.5
        self.sensor._last_calculation_time = time.time()

        # Mock async_write_ha_state
        self.sensor.async_write_ha_state = AsyncMock()

        # Call update handler (async)
        await self.sensor._handle_update()

        # Cache should be cleared
        self.assertIsNone(self.sensor._last_temp)
        self.assertIsNone(self.sensor._last_humidity)
        self.assertIsNone(self.sensor._last_absolute_humidity)
        self.assertEqual(self.sensor._last_calculation_time, 0.0)


if __name__ == "__main__":
    unittest.main()
